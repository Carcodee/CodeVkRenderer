#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout :enable

#include "../Utils/uStructs.glsl"
#include "../Utils/uMath.glsl"
#include "../Utils/uRendering.glsl"

layout (set = 0, binding = 0, scalar) buffer PointLights{
    u_PointLight[] pointLights;
};
layout (set = 0, binding = 1, scalar) writeonly buffer LightMap{
    u_ArrayIndexer[] lightMap;
};
layout (set = 0, binding = 2, scalar) writeonly buffer LightIndices{
    int[] lightIndices;
};
layout(set = 0, binding = 3, scalar) uniform CameraProperties{
    mat4 invProj;
    mat4 invView;
}cProps;

layout(push_constant)uniform pushConstants{
    int sWidth;
    int sHeight;
    int pointLightsCount;
}pc;

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define TILESIZE 32

void main() {

    
    uvec2 tileId = gl_GlobalInvocationID.xy;
    
    vec2 tileSize = vec2(pc.sWidth / TILESIZE, pc.sHeight / TILESIZE);
    vec2 screenSize = vec2(pc.sWidth, pc.sHeight);

    vec2 min = (tileSize * tileId);
    vec2 max = (min + tileSize);

//    min = 2 * min/screenSize  - 1.0;
//    max = 2 * max/screenSize - 1.0;

    min = min/screenSize;
    max = max/screenSize;
    
    vec3 minWs = u_ScreenToWorld(cProps.invProj, cProps.invView, 0.0f, min);
    vec3 maxWs = u_ScreenToWorld(cProps.invProj, cProps.invView, 1.0f, max);
    
    vec3 minBounds = u_Min(minWs, maxWs);
    vec3 maxBounds = u_Max(minWs, maxWs);

    
    //just to prevent collision, even if is less likely to have all lights in the same tile
    int maxLightsPerTile= pc.pointLightsCount;
    
    int idxIndexer = int(tileId.x) * TILESIZE + int(tileId.y);
    int idxLightIndicesStart = idxIndexer * maxLightsPerTile;
    
    int lightCount = 0;
    for(int i = 0; i < pc.pointLightsCount; i++){
//        vec4 pointLightSp = inverse(cProps.invProj) * inverse(cProps.invView) * vec4(pointLights[i].pos,1.0);
//        if(pointLightSp.w == 0) continue;
//        pointLightSp/= pointLightSp.w;
//        vec4 lightRadiusOffsetSp = inverse(cProps.invProj) * inverse(cProps.invView) * vec4(pointLights[i].pos + vec3(pointLights[i].radius, 0.0, 0.0),1.0);
//        if(lightRadiusOffsetSp.w == 0) continue;
//        lightRadiusOffsetSp /= lightRadiusOffsetSp.w;
//        float radiusSp = distance(lightRadiusOffsetSp, pointLightSp);
//        if(u_SDF_AABB_Sphere(min, max, pointLightSp.xy, radiusSp)){
//            int idx = idxLightIndicesStart + lightCount;
//            lightIndices[idx] = i; 
//            lightCount++;
//        };
        if(u_SDF_AABB_Sphere(minBounds, maxBounds, pointLights[i].pos, pointLights[i].radius)){
            int idx = idxLightIndicesStart + lightCount;
            lightIndices[idx] = i;
            lightCount++;
        };
    }
    atomicAdd(lightMap[idxIndexer].offset, idxLightIndicesStart);
    atomicAdd(lightMap[idxIndexer].size, lightCount);
}