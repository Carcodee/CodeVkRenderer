#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout :enable

#include "../Utils/uStructs.glsl"
#include "../Utils/uMath.glsl"
#include "../Utils/uRendering.glsl"

layout (set = 0, binding = 0, scalar) buffer PointLights{
    u_PointLight[] pointLights;
};
layout (set = 0, binding = 1, scalar) writeonly buffer LightMap{
    u_ArrayIndexer[] lightMap;
};
layout (set = 0, binding = 2, scalar) writeonly buffer LightIndices{
    int[] lightIndices;
};
layout(set = 0, binding = 3, scalar) uniform CameraProperties{
    mat4 invProj;
    mat4 invView;
    vec3 camPos;
}cProps;

layout(push_constant)uniform pushConstants{
    int sWidth;
    int sHeight;
    int pointLightsCount;
    uint tileCountX;
    uint tileCountY;
}pc;

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define TILE_PX_SIZE 32

void main() {

    
    uvec2 tileId = gl_GlobalInvocationID.xy;
    
    vec2 tileSize = vec2(TILE_PX_SIZE, TILE_PX_SIZE);
    vec2 screenSize = vec2(pc.sWidth, pc.sHeight);

    vec2 ndcSizePerTile = 2 * (tileSize/screenSize);
    vec2 upperLeft = vec2(-1.0);
    
    
    vec2 topL = (upperLeft + tileId * ndcSizePerTile);
    vec2 topR = vec2(topL.x + ndcSizePerTile.x, topL.y);
    vec2 bottonR = (topL + ndcSizePerTile);
    vec2 bottonL = vec2(topL.x, topL.y + ndcSizePerTile);
    

    vec3 nearTopL = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 0.0, topL);
    vec3 nearTopR = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 0.0, topR);
    vec3 nearBottomL = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 0.0,  bottonL);
    vec3 nearBottomR = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 0.0,  bottonR);

    vec3 farTopL = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 1.0, topL);
    vec3 farTopR = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 1.0, topR);
    vec3 farBottomL = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 1.0,  bottonL);
    vec3 farBottomR = u_ScreenToWorldNDC(cProps.invProj, cProps.invView , 1.0,  bottonR);

    u_Frustum tileFrustum;
    
    //left
    tileFrustum.planes[0] = u_GetPlane(nearTopL, cProps.camPos, nearBottomL);

    // Right Plane
    tileFrustum.planes[1] = u_GetPlane(cProps.camPos, nearTopR, nearBottomR);

    // Top Plane
    tileFrustum.planes[2] = u_GetPlane(cProps.camPos, nearTopL, nearTopR);

    // Bottom Plane
    tileFrustum.planes[3] = u_GetPlane(cProps.camPos, nearBottomR, nearBottomL);

    // Near Plane
    tileFrustum.planes[4] = u_GetPlane(nearTopL, nearBottomR, nearBottomL);

    // Far Plane
    tileFrustum.planes[5] = u_GetPlane(farTopL, farBottomL, farBottomR);

    //just to prevent collision, even if is less likely to have all lights in the same tile
    int maxLightsPerTile= pc.pointLightsCount;
    
    uint idxIndexer = tileId.y * pc.tileCountX + tileId.x;
    uint idxLightIndicesStart = (idxIndexer * maxLightsPerTile);
    
    int lightCount = 0;

    for(int i = 0; i < pc.pointLightsCount; i++){

//        vec4 pointLightVs = inverse(cProps.invView) * vec4(pointLights[i].pos,1.0);
//        vec4 endPosVs = inverse(cProps.invView) * vec4(pointLights[i].pos + vec3(pointLights[i].radius, 0.0, 0.0), 1.0f);
//        float radiusVs = distance(endPosVs, pointLightVs);
        
        bool insideFrustum = true;
        for(int j = 0; j < 6; j++){
            int planeIdx = j;
            if(!u_SphereInsidePlane(pointLights[i].pos, pointLights[i].radius, tileFrustum.planes[planeIdx].xyz, tileFrustum.planes[planeIdx].w)){
                insideFrustum = false;
                break;
            }
        }
        
        if(insideFrustum){
            int idx = int(idxLightIndicesStart + lightCount);
            lightIndices[idx] = i;
            lightCount++;
        };
    }

//        lightMap[idxIndexer].offset= tileFrustum.planes[1].x;
//        lightMap[idxIndexer].size= tileFrustum.planes[1].w;
    atomicAdd(lightMap[idxIndexer].offset, int(idxLightIndicesStart));
    atomicAdd(lightMap[idxIndexer].size, lightCount);
}