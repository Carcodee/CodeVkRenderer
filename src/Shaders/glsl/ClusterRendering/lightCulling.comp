#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout :enable

#include "../Utils/uStructs.glsl"
#include "../Utils/uMath.glsl"
#include "../Utils/uRendering.glsl"

layout (set = 0, binding = 0, scalar) buffer PointLights{
    u_PointLight[] pointLights;
};
layout (set = 0, binding = 1, scalar) writeonly buffer LightMap{
    u_ArrayIndexer[] lightMap;
};
layout(set = 0, binding = 2, scalar) uniform CameraProperties{
    mat4 invProj;
    mat4 invView;
}cProps;

layout(push_constant)uniform pushConstants{
    int sWidth;
    int sHeight;
}pc;

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define TILESIZE 32

void main() {

    
    uvec2 tileId = gl_GlobalInvocationID.xy;
    
    vec2 tileSize = vec2(pc.sWidth / TILESIZE, pc.sHeight / TILESIZE);

    vec2 min = (tileSize * tileId);
    vec2 max = (min + tileSize);

//    min /= vec2(pc.sWidth, pc.sHeight);
//    max /= vec2(pc.sWidth, pc.sHeight);

//    vec3 wsMin = u_ScreenToWorld(cProps.invProj, cProps.invView, 0.0, vec2(0.0));
//    vec3 wsMax = u_ScreenToWorld(cProps.invProj, cProps.invView, 1.0, vec2(1.0));

    int idxIndexer = int(tileId.x) * TILESIZE + int(tileId.y);


    lightMap[idxIndexer].offset = min.x;
    lightMap[idxIndexer].size = min.y;
    int lightCount = 0;
    for(int i = 0; i < 1024; i++){

        vec4 pointLightSp = inverse(cProps.invProj) * inverse(cProps.invView) * vec4(pointLights[i].pos,1.0);
        if(u_SDF_AABB(min, max, pointLightSp.xy)){
            lightCount++;
        };
    }

//    atomicAdd(lightMap[idxIndexer].offset, lightCount);
//    atomicAdd(lightMap[idxIndexer].size, lightCount);
}